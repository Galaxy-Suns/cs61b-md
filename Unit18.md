# 哈希表
 
* [构建集合和映射更快的数据结构](#构建集合和映射更快的数据结构)
* [数字在箱子集合中](#数字在箱子集合中)
* [非数字元素在箱子集合中](#非数字元素在箱子集合中)
* [对象转换为数字](#对象转换为数字)
* [哈希码](#哈希码)
* [关于哈希表的一些事情](#关于哈希表的一些事情)
  * [自定义哈希函数的必要性](#自定义哈希函数的必要性)
  * [可变性与哈希表](#可变性与哈希表)
 

## 构建集合和映射更快的数据结构

这是当前集合和列表的底层实现方式和时间复杂度

![](img/fe747552.png)

我们可以做的更好吗

* 我们有时无法判断两个事物的大小关系，因此搜索树相关的算法不太可行 用户层面，似乎集合或者映射不太需要必须存储可比较大小的事物
* 并且我们希望在复杂度上做出改进 比log n更好

我们考虑一个集合，并存在两个操作

* 添加操作，并假设我们永远不会尝试添加已经在集合中的东西
* 包含操作，检查给定项是否在集合中

有时候，把自己投射到数据结构的视角上有助于我们构建数据结构

* 假设现有有一堵墙和一支铅笔
* 当我们要检查一个数字`1`，我们查看墙上是否有1？没有的话，我们返回False，

![](img/d051e098.png)

* 当我们添加一个数字`5`时，在墙上空白处添加5

但是这足够快吗？如果墙上有很多数字怎么办？

![](img/aa3b4550.png)

添加似乎足够快，但是查找呢？

我们需要查看每个数字

如果这样呢？

![](img/5c9a4f8b.png)

查找的效率很差，最坏需要完整遍历整个集合

改进或许我们可以选择排序（树算法等），这样插入查找都是O(log n)，然而需要考虑有些事物无法排序

## 数字在箱子集合中

一种优化方案，我们想一下麦当劳的取餐架。

![](img/cd8500e6.png)

我们的食物被**分配一个数字**，并且被放置在数字最后一位对应的位置上，我们只需要去查找这个位置所有数字，得到数字对应的食物

同样插入时也是这样，效率很高

![](img/93ba26da.png)

* 但是仅仅通过各位分类只是将原来的时间变为1/10，而随着数据的不断增多，依据面临之前的问题
* 这种算法也会浪费一些空间，我们不得不留出一些空间给每个箱子，以便未来插入
* 如果每个箱子装满怎么办

**空间上** 我们不给每个箱子赋予一定的空间，而是动态空间，如**链表**

**时间上** 如果有M个箱子，共计N个元素，那么查找和插入的时间复杂度大概是θ(N/M) 因此，我们需要使得M不是一个常数，而是一个和N正相关的东西 来降低θ(N)的复杂度

* 我们可以在最大箱子的大小超过k时增加m，但是事实证明箱子的平均大小超过k时增加m更有效，具体增加多少呢？
* 指数增加（加倍）会得到常数的摊销时间复杂度 这和我们实现列表时的数组扩容相近

假设现在当n/m大于1.5时，我们调整m为两倍，并且分组的依据是`i%m`

![](img/642ccf9c.png)

* `N/M`永远几乎是一个常数

## 非数字元素在箱子集合中

对于元素非数字的集合来说，比如说单词`cat`，我们把它放在什么箱子中？

* 首先将单词的首字母作为分组依据，可以将其编号`A-0 B-1 C-2 ...` 放入26个不同的桶
* 当`n/m`达到一定时，我们需要扩增桶，按照前两个字母划分26*26个桶

这种方法的缺点是

* 每个字母的出现概率并不相同,以s开头的单词最多
* 比当前桶划分更短的单词比如`a`不能放入`aa`这种两字母长桶中
* 集合每次resize不是加倍而是特定的26倍，这与字母的属性密切相关，我们希望不需要知道对象的属性（这不是集合必须要进行的工作），就可以将其放入集合 

因此这种方法只能**完美适用于整数**

但是可否能将对象转换为整数？？

## 对象转换为数字

字符串？

* *使用ASCII/Unicode？* 
* *相加所有字母的ASCII？*
* *26进制？*
* *字母的个数？*

我们需要使得数字分布尽可能均匀 上面一些方法可能在此点上不好

26进制是这样 不过其中没有0 

![](img/8035578c.png)

根据进制转换的一一对应性，每个单词有唯一的二十六进制，因此有唯一的十进制数字

因此接下来可以利用箱子集合，整个流程如下

![](img/9952fa30.png)

其中函数的作用就是字符串转数字

为了更广泛的字符串，不仅仅表示26个字母，我们可以使用ASCII(此时就是126进制）或者Unicode

![](img/f9b965d1.png)

但是对于Unicode，一个字符串的对应进制数字就是一个天文数字了。java中存在溢出 

## 哈希码

从一个无限或有限的集合中取值，并最终降至有限多项的集合中。我们的目标集合是Java中的整数集合`4,294,967,296`项

注意由于初始范围可能比目标范围大，因此无法为每一个字符串获取**唯一**的值 但是碰撞并不常见

Java中使用31作为转换进制

![](img/8a4b0e6c.png)

![](img/cd33e233.png)

在Java中，所有对象都从Object上继承了一个hashCode()方法，默认返回其当前所在的内存地址 有些随机，在同一台机器上重复运行时也不会保持一致

而字符串重写了这个方法基本如下

![](img/155e4580.png)

**一个特殊情况**

* 如果一个东西的hashCode是-1，我们应当将其放在最后一个箱子，应当使用Math.floorMod取余数

![](img/11093beb.png)

最终集合和映射的复杂度为θ(1)，只要是均匀分布（否则都装在一个箱子中，而我们扩增箱子又是通过箱子的平均决定。退化为θ(n)

## 关于哈希表的一些事情

1. 对于hashCode，会返回一个和内存地址关联是数字，对于Java来说，其在模拟程序在计算机中的运行，因此并不随机，而是重复执行偶尔会重复出现在一些特定的地方
2. 如果`hashCode`永远返回0，那我们就永远将元素放入同一盒子，效率会退化为O(n)

![](img/ac354742.png)

3. hash函数可以自定义产生，比如我们的元素是数字，我们可以就返回数字 这样非常完美，也均匀分布

![](img/8bc1d48a.png)

4. 我们甚至可以为了随机性在对象创建时为其绑定一个随机数

总而言之，哈希函数的目标是使得项目分散的尽可能广泛

默认的哈希函数是内存地址的函数，实际上是一种广泛的随机

### 自定义哈希函数的必要性

那么我们为什么还要自定义？？

比如有两个对象，对象和数字两个属性，二者数字相同，尽管他们有各自的颜色，但是此时我们期望在`equals`时返回true，而外界看待两者也是相同。当我们添加到集合中时，**在已经添加其中一个时，检查另一个是否在集合，我们期望一定得到true**

因此，**由于哈希表在判断一个箱子中有否已经有元素时使用`equals`**，我们需要保持`equals`和`hashcode`之间的一致来保证哈希表正常工作 如果两个事物equal，应当有相同的hashcode

### 可变性与哈希表

在Java中，不可变数据类型是指一旦创建就无法更改的数据类型

![](img/caf651ce.png)

对象的属性后续会改变、数组的元素后续会改变，这些都是可变类型

不可变类型不单单通过`final`修饰，被其修饰的是不可更改，此外`private`的属性在外界眼中是不存在的，而图中Date的所有属性**在外界眼中**都不可变，因此，整体不可变

但是这种是可变的

![](img/772f2148.png)

因为只是rocks的指向不可变，但是数组内部还是可以修改的

![](img/28d20a7b.png)

这个也是可变的！因为我们仍然可以在外界创建数组，通过外界的指针修改内部的数组

要完全隔离内外。如果要使得某个类不可变，不要给外界可以保留内部引用的机会

典型的不可变对象是**字符串** **整数**

在Java中的List，其可以通过方法更改内部，因此是可变类型。而其哈希码是其内部元素的某种组合，这一点和`equals`配合也很好，当两个列表元素相同，其`equals`返回true，并且哈希码一致

更改可变对象后，其哈希值发生变化。但是如果我们在改变之前将对象放入哈希表，**在哈希值变化后，我们无法在哈希表中找到这个可变对象！**

因此，**可变对象不能作为哈希表的key!** value无所谓，其绑定到key的，和哈希表的查找无关

此外，这是Java中内置的哈希表的实现

![](img/8ac7f291.png)

其用了k=0.75，因此平均上永远不会发生碰撞

而且Java在箱子较大时使用红黑树。故最坏只会退化为log n
