## 图的接口和API
 
* [图的接口和API](#图的接口和API)
* [图的实现](#图的实现)
  * [图的算法的实现](#图的算法的实现)
  * [表示图的数据结构](#表示图的数据结构)
    * [邻接矩阵](#邻接矩阵)
    * [邻接数组表示](#邻接数组表示)
  * [复杂度分析](#复杂度分析)
* [广度优先搜索_BFS](#广度优先搜索_BFS)

图作为**抽象类型**要为用户提供什么服务或方法

![](img/4a1c5d0f.png)

在决定抽象类型接口的阶段，我们的决策会影响**具体实现数据结构所能达到的时间复杂度** **内存使用** **实现图类的代码复杂度**

1. 首先我们决定节点的值只可以是数字，对于其他类型，我们可以额外引入映射到图上

![](img/a178c871.png)

2. 功能如下

![](img/aed21ee0.png)

* 在创建图时就要告知图中有多少节点 并且不可增减节点
* 允许任意**添加边**
* `adj`询问图中和v相邻的所有节点
* 总共有多少节点
* 总共有多少边

对于一些其它功能需要自己动手实现

![](img/cd7e1db9.png)

打印可以利用其特供的接口

![](img/aecc1697.png)

## 图的实现

### 图的算法的实现

在此之前我们想一下**如何表示深度优先路径算法**

可以构建一个类来表示

![](img/33be3b57.png)

我们向这个**路径器**提问，来获得答案

也可以集成到图类中

### 表示图的数据结构

在内存中如何组织，我们用什么数据结构来实现

#### 邻接矩阵

创建一个二维表，其中每一项表示，两个节点间是否存在边

![](img/507b23b1.png)

#### 邻接数组表示

邻接矩阵的缺点是**浪费了很多空间**尤其对于稀疏图（有很多节点，但是边却相对较少）

矩阵的大部分都是0

![](img/1c430c7d.png)

邻接数组是一个**列表的数组**

每个列表告诉**对应的节点与哪些节点相连**

### 复杂度分析

![](img/b176f7c7.png)

使用邻接列表表示，这个打印操作的复杂度要分情况考虑

因为最坏情况下，每个节点都与其余节点相邻 θ(V^2)

最好情况则是θ(V) 每个节点都不与其他节点相邻 只需要从数组头走到尾 

但是当我们引入另一个变量E时，情况就发生变化，每个节点的列表内，其之和只能有E条边 因此复杂度θ(V+E)

并且这个复杂度可以看错由**其相对较大的项主导** 对于很稀疏的图，近似于θ(V) 对于边非常密集的图 近似 θ(E)

![](img/1eb0e3c9.png)

深度优先搜索、深度优先路径的复杂度也是θ(V+E) 分析方法和上述一致

## 广度优先搜索_BFS

在树中等价于**层序遍历**

从源头出发

遍历所有离源头距离1的节点，所有距离2的节点...

![](img/725f03dc.png)

实现可以使用一个队列（可以从前面出队，从后面入队的一种数据结构）

刚开始将源头入队

之后，循环出队，当出队时，将没有遍历过的、出队顶点的邻节点入队。入队后直到队列为空完成遍历

并且基于此也可以构建**广度优先路径**算法 每个节点到给定节点的最短路径（无权）

遍历时记下引起入队的出队前顶点，同时可以记下目前的路径长度（出队顶点的路径长度+1）

![](img/e284afd1.png)

最终

![](img/67bd5b8a.png)

时间复杂度同样是O(V+E)
